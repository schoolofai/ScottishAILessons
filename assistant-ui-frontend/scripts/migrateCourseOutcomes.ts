#!/usr/bin/env ts-node

/**
 * Migration script to import redesigned course_outcomes from SQA data
 *
 * This script:
 * 1. Reads course_outcomes_import.json (generated by extractSQAOutcomes.ts)
 * 2. Backs up existing course_outcomes for the course
 * 3. Deletes old course_outcomes documents
 * 4. Creates new documents with SQA-aligned structure
 * 5. Validates the import
 *
 * Usage:
 *   tsx scripts/migrateCourseOutcomes.ts <courseId>
 *
 * Example:
 *   tsx scripts/migrateCourseOutcomes.ts course_c84473
 *
 * Requirements:
 *   - NEXT_PUBLIC_APPWRITE_ENDPOINT environment variable
 *   - NEXT_PUBLIC_APPWRITE_PROJECT_ID environment variable
 *   - APPWRITE_API_KEY environment variable (admin API key)
 *   - course_outcomes_import.json file (generated by extractSQAOutcomes.ts)
 */

import * as fs from 'fs';
import * as path from 'path';
import { Client, Databases, ID, Query } from 'node-appwrite';
import * as dotenv from 'dotenv';

// Load environment variables
dotenv.config({ path: path.join(__dirname, '../.env.local') });

interface CourseOutcomeImport {
  courseId: string;
  courseSqaCode: string;
  unitCode: string;
  unitTitle: string;
  scqfCredits: number;
  outcomeId: string;
  outcomeTitle: string;
  assessmentStandards: string;
  teacherGuidance: string;
  keywords: string[];
}

async function migrateCourseOutcomes(courseId: string) {
  console.log('üîÑ Course Outcomes Migration Script');
  console.log('=' .repeat(60));
  console.log(`  Target Course ID: ${courseId}`);
  console.log('=' .repeat(60) + '\n');

  // Validate environment variables
  const endpoint = process.env.NEXT_PUBLIC_APPWRITE_ENDPOINT;
  const projectId = process.env.NEXT_PUBLIC_APPWRITE_PROJECT_ID;
  const apiKey = process.env.APPWRITE_API_KEY;

  if (!endpoint || !projectId || !apiKey) {
    console.error('‚ùå Missing required environment variables:');
    if (!endpoint) console.error('  - NEXT_PUBLIC_APPWRITE_ENDPOINT');
    if (!projectId) console.error('  - NEXT_PUBLIC_APPWRITE_PROJECT_ID');
    if (!apiKey) console.error('  - APPWRITE_API_KEY');
    process.exit(1);
  }

  console.log('‚úÖ Environment variables validated\n');

  // Create admin client
  const adminClient = new Client()
    .setEndpoint(endpoint)
    .setProject(projectId)
    .setKey(apiKey);

  const databases = new Databases(adminClient);

  try {
    // ============================================================
    // STEP 1: Read import file
    // ============================================================
    const importFilePath = path.join(__dirname, '../../langgraph-author-agent/data/course_outcomes_import.json');

    console.log(`üìñ Reading import file: ${importFilePath}\n`);

    if (!fs.existsSync(importFilePath)) {
      console.error(`‚ùå Import file not found: ${importFilePath}`);
      console.error(`   Please run extractSQAOutcomes.ts first to generate the import file.`);
      process.exit(1);
    }

    const fileContent = fs.readFileSync(importFilePath, 'utf-8');
    const importData: CourseOutcomeImport[] = JSON.parse(fileContent);

    // Filter for the specified course
    const courseImportData = importData.filter(item => item.courseId === courseId);

    if (courseImportData.length === 0) {
      console.error(`‚ùå No import data found for courseId: ${courseId}`);
      console.error(`   Available course IDs in import file:`);
      const uniqueCourseIds = [...new Set(importData.map(item => item.courseId))];
      uniqueCourseIds.forEach(id => console.error(`     - ${id}`));
      process.exit(1);
    }

    console.log(`‚úÖ Loaded ${courseImportData.length} course outcomes for ${courseId}\n`);

    // ============================================================
    // STEP 2: Backup existing course_outcomes
    // ============================================================
    console.log('üíæ Backing up existing course_outcomes...\n');

    const existingResult = await databases.listDocuments(
      'default',
      'course_outcomes',
      [
        Query.equal('courseId', courseId),
        Query.limit(500)
      ]
    );

    const backupPath = path.join(__dirname, '../../langgraph-author-agent/data/course_outcomes_backup.json');

    if (existingResult.documents.length > 0) {
      fs.writeFileSync(
        backupPath,
        JSON.stringify(existingResult.documents, null, 2),
        'utf-8'
      );
      console.log(`‚úÖ Backed up ${existingResult.documents.length} existing documents to:`);
      console.log(`   ${backupPath}\n`);
    } else {
      console.log(`‚ÑπÔ∏è  No existing course_outcomes found for ${courseId}\n`);
    }

    // ============================================================
    // STEP 3: Delete old course_outcomes
    // ============================================================
    if (existingResult.documents.length > 0) {
      console.log('üóëÔ∏è  Deleting old course_outcomes...\n');

      let deleteCount = 0;
      for (const doc of existingResult.documents) {
        try {
          await databases.deleteDocument('default', 'course_outcomes', doc.$id);
          deleteCount++;
          console.log(`  üóëÔ∏è  Deleted: ${doc.$id}`);
        } catch (error: any) {
          console.error(`  ‚ùå Failed to delete ${doc.$id}: ${error.message}`);
        }
      }

      console.log(`\n‚úÖ Deleted ${deleteCount} old documents\n`);
    }

    // ============================================================
    // STEP 4: Import new course_outcomes
    // ============================================================
    console.log('üì• Importing new course_outcomes...\n');

    let createdCount = 0;
    let errorCount = 0;
    const createdDocIds: string[] = [];

    for (const outcomeData of courseImportData) {
      try {
        // Prepare document data
        const docData: any = {
          courseId: outcomeData.courseId,
          courseSqaCode: outcomeData.courseSqaCode,
          unitCode: outcomeData.unitCode,
          unitTitle: outcomeData.unitTitle,
          scqfCredits: outcomeData.scqfCredits,
          outcomeId: outcomeData.outcomeId,
          outcomeTitle: outcomeData.outcomeTitle,
          assessmentStandards: outcomeData.assessmentStandards,
          teacherGuidance: outcomeData.teacherGuidance,
          keywords: JSON.stringify(outcomeData.keywords)
        };

        // Create document
        const doc = await databases.createDocument(
          'default',
          'course_outcomes',
          ID.unique(),
          docData
        );

        createdDocIds.push(doc.$id);
        createdCount++;
        console.log(`  ‚úÖ Created: ${outcomeData.outcomeId} - ${outcomeData.outcomeTitle} (${doc.$id})`);

      } catch (error: any) {
        errorCount++;
        console.error(`  ‚ùå Failed: ${outcomeData.outcomeId} - ${error.message}`);
      }
    }

    console.log(`\nüìä Import Summary:`);
    console.log(`   Created: ${createdCount}`);
    console.log(`   Errors: ${errorCount}`);
    console.log(`   Total: ${courseImportData.length}\n`);

    if (errorCount > 0) {
      console.error(`‚ö†Ô∏è  Migration completed with ${errorCount} errors. Please review logs above.`);
      process.exit(1);
    }

    // ============================================================
    // STEP 5: Validate import
    // ============================================================
    console.log('‚úÖ Validating import...\n');

    // Check all outcomeIds are present
    const outcomeIds = courseImportData.map(item => item.outcomeId);
    let validationErrors = 0;

    for (const outcomeId of outcomeIds) {
      const result = await databases.listDocuments(
        'default',
        'course_outcomes',
        [
          Query.equal('courseId', courseId),
          Query.equal('outcomeId', outcomeId),
          Query.limit(1)
        ]
      );

      if (result.documents.length === 0) {
        console.error(`  ‚ùå Missing: ${outcomeId}`);
        validationErrors++;
      } else {
        console.log(`  ‚úÖ ${outcomeId}: ${result.documents[0].outcomeTitle}`);
      }
    }

    console.log('');

    if (validationErrors > 0) {
      console.error(`‚ùå Validation failed: ${validationErrors} outcome(s) missing`);
      process.exit(1);
    }

    console.log('=' .repeat(60));
    console.log('üéâ Migration Complete!');
    console.log('=' .repeat(60));
    console.log(`  ‚úÖ Imported ${createdCount} course outcomes`);
    console.log(`  ‚úÖ All outcome IDs validated`);
    console.log(`  ‚úÖ Ready for seedAuthoredSOW.ts\n`);

    // Show sample document
    if (createdDocIds.length > 0) {
      const sampleDoc = await databases.getDocument('default', 'course_outcomes', createdDocIds[0]);
      console.log('üìù Sample course_outcomes document:');
      console.log('=' .repeat(60));
      console.log(`  $id: ${sampleDoc.$id}`);
      console.log(`  courseId: ${sampleDoc.courseId}`);
      console.log(`  courseSqaCode: ${sampleDoc.courseSqaCode}`);
      console.log(`  unitCode: ${sampleDoc.unitCode}`);
      console.log(`  outcomeId: ${sampleDoc.outcomeId}`);
      console.log(`  outcomeTitle: ${sampleDoc.outcomeTitle}`);
      console.log(`  keywords: ${sampleDoc.keywords}`);
      console.log('=' .repeat(60) + '\n');
    }

  } catch (error: any) {
    console.error('\n‚ùå Migration failed:');
    console.error(error);

    if (error.code === 401) {
      console.error('\nüí° Tip: Ensure your APPWRITE_API_KEY has full access to course_outcomes collection');
    } else if (error.code === 404) {
      console.error('\nüí° Tip: Ensure the course_outcomes collection exists in the default database');
    }

    process.exit(1);
  }
}

// Parse command line arguments
const args = process.argv.slice(2);

if (args.length !== 1) {
  console.error('Usage: tsx scripts/migrateCourseOutcomes.ts <courseId>');
  console.error('Example: tsx scripts/migrateCourseOutcomes.ts course_c84473');
  process.exit(1);
}

const [courseId] = args;

// Run migration
migrateCourseOutcomes(courseId)
  .then(() => {
    console.log('üëã Exiting...');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\n‚ùå Unexpected error:');
    console.error(error);
    process.exit(1);
  });
