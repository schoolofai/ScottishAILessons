"""Phase 1 E2E Test: Outline Generation for Applications of Mathematics Higher.

This test runs the real Claude Agent SDK to generate a lesson outline
for course_c84476 (Applications of Mathematics Higher).

Target Course:
    - courseId: course_c84476
    - subject: applications-of-mathematics
    - level: higher
    - structure_type: skills_based

Expected Behavior:
    - Course_outcomes.json extracted from Appwrite
    - lesson_outline.json generated by Claude SDK
    - Outline passes Pydantic validation
    - structure_type = skills_based
    - 10-25 lessons (realistic for Higher course)
    - Exactly 1 mock_exam (must be within last 3 lessons)
    - All lessons are either 'teach' or 'mock_exam' (simplified outline types)

IMPORTANT: Uses simplified architecture:
    - OutlineLessonType: Only 'teach' and 'mock_exam' for outline entries
    - CardType: Only 'starter', 'explainer', 'modelling', 'guided_practice', 'exit_ticket' (5 cards)
    - Independent practice is handled by a SEPARATE system outside of SOW authoring

Note: This test requires:
    - Valid Anthropic API key
    - Appwrite connectivity
    - May take 1-3 minutes to complete
"""

import asyncio
import json
import pytest
from pathlib import Path

import sys

# Add src to path for imports
CLAUD_AUTHOR_AGENT_ROOT = Path(__file__).parent.parent.parent
if str(CLAUD_AUTHOR_AGENT_ROOT) not in sys.path:
    sys.path.insert(0, str(CLAUD_AUTHOR_AGENT_ROOT))


# ═══════════════════════════════════════════════════════════════════════════════
# Test Configuration
# ═══════════════════════════════════════════════════════════════════════════════

# Target course for testing
TARGET_COURSE_ID = "course_c84476"
EXPECTED_SUBJECT = "applications-of-mathematics"
EXPECTED_LEVEL = "higher"
EXPECTED_STRUCTURE_TYPE = "skills_based"

# Reasonable lesson count range for Higher level course
MIN_LESSONS = 10
MAX_LESSONS = 30


# ═══════════════════════════════════════════════════════════════════════════════
# Fixtures
# ═══════════════════════════════════════════════════════════════════════════════

@pytest.fixture(scope="module")
def event_loop():
    """Create event loop for async tests."""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()


@pytest.fixture(scope="module")
def outline_result(event_loop):
    """Generate outline once for all tests in this module.

    This fixture runs the actual Claude Agent SDK to generate an outline
    for the target course. Results are cached for all tests.

    Returns:
        Dictionary with outline, paths, and metadata
    """
    from src.iterative_sow_author import IterativeSOWAuthor

    async def generate_outline():
        author = IterativeSOWAuthor(
            mcp_config_path=str(CLAUD_AUTHOR_AGENT_ROOT / ".mcp.json"),
            persist_workspace=True,
            log_level="DEBUG"
        )

        return await author._test_phase1_outline_only(TARGET_COURSE_ID)

    return event_loop.run_until_complete(generate_outline())


# ═══════════════════════════════════════════════════════════════════════════════
# E2E Tests
# ═══════════════════════════════════════════════════════════════════════════════

class TestPhase1OutlineGeneration:
    """E2E tests for Phase 1 outline generation."""

    def test_outline_generated_successfully(self, outline_result):
        """Test that outline was generated without errors."""
        assert outline_result is not None, "Outline generation returned None"
        assert "outline" in outline_result, "Result missing 'outline' key"
        assert outline_result["outline"] is not None, "Outline is None"

    def test_workspace_files_created(self, outline_result):
        """Test that workspace files were created."""
        workspace_path = Path(outline_result["workspace_path"])
        assert workspace_path.exists(), f"Workspace not found: {workspace_path}"

        course_outcomes_path = Path(outline_result["course_outcomes_path"])
        assert course_outcomes_path.exists(), f"Course_outcomes.json not found: {course_outcomes_path}"

        outline_path = Path(outline_result["outline_path"])
        assert outline_path.exists(), f"lesson_outline.json not found: {outline_path}"

    def test_course_outcomes_json_valid(self, outline_result):
        """Test that Course_outcomes.json is valid JSON with expected structure."""
        course_outcomes_path = Path(outline_result["course_outcomes_path"])
        content = course_outcomes_path.read_text()

        # Should parse as JSON
        data = json.loads(content)

        # Should have required fields
        assert "courseId" in data, "Course_outcomes.json missing courseId"
        assert "structure_type" in data, "Course_outcomes.json missing structure_type"
        assert "outcomes" in data, "Course_outcomes.json missing outcomes"

        # Should match target course
        assert data["courseId"] == TARGET_COURSE_ID

    def test_structure_type_is_skills_based(self, outline_result):
        """Test that structure_type is skills_based (required for Higher level)."""
        assert outline_result["structure_type"] == EXPECTED_STRUCTURE_TYPE, \
            f"Expected structure_type='{EXPECTED_STRUCTURE_TYPE}', got '{outline_result['structure_type']}'"

    def test_outline_total_lessons_matches_array(self, outline_result):
        """Test that total_lessons matches outlines array length."""
        outline = outline_result["outline"]

        assert outline["total_lessons"] == len(outline["outlines"]), \
            f"total_lessons ({outline['total_lessons']}) != len(outlines) ({len(outline['outlines'])})"

    def test_outline_lesson_count_realistic(self, outline_result):
        """Test that lesson count is realistic for Higher course."""
        total = outline_result["total_lessons"]

        assert MIN_LESSONS <= total <= MAX_LESSONS, \
            f"Expected {MIN_LESSONS}-{MAX_LESSONS} lessons, got {total}"

    def test_outline_has_sequential_order(self, outline_result):
        """Test that outline entries have sequential order 1, 2, 3..."""
        outline = outline_result["outline"]
        orders = [e["order"] for e in outline["outlines"]]

        expected = list(range(1, len(orders) + 1))
        assert orders == expected, f"Order not sequential: got {orders}, expected {expected}"

    def test_outline_has_exactly_one_mock_exam(self, outline_result):
        """Test that outline has exactly 1 mock_exam lesson."""
        outline = outline_result["outline"]
        lesson_types = [e["lesson_type"] for e in outline["outlines"]]

        mock_count = lesson_types.count("mock_exam")
        assert mock_count == 1, f"Expected exactly 1 mock_exam, found {mock_count}"

    def test_outline_has_teach_lessons(self, outline_result):
        """Test that outline has at least 1 teach lesson."""
        outline = outline_result["outline"]
        lesson_types = [e["lesson_type"] for e in outline["outlines"]]

        teach_count = lesson_types.count("teach")
        assert teach_count >= 1, f"Expected at least 1 teach lesson, found {teach_count}"

    def test_outline_uses_simplified_lesson_types(self, outline_result):
        """Test that outline only uses simplified lesson types (teach + mock_exam).

        NOTE: The new iterative architecture uses simplified lesson types:
        - 'teach' for all content delivery lessons (uses 5-card flow)
        - 'mock_exam' for final exam preparation
        - Independent practice is handled by a SEPARATE system outside of SOW authoring
        """
        outline = outline_result["outline"]
        valid_outline_types = {"teach", "mock_exam"}

        for i, entry in enumerate(outline["outlines"]):
            lesson_type = entry.get("lesson_type")
            assert lesson_type in valid_outline_types, \
                f"Entry {i+1} has invalid outline lesson_type '{lesson_type}'. " \
                f"Only {valid_outline_types} are valid for outlines."

    def test_outline_subject_matches_target(self, outline_result):
        """Test that outline subject matches target course."""
        outline = outline_result["outline"]
        assert outline["course_subject"] == EXPECTED_SUBJECT, \
            f"Expected subject '{EXPECTED_SUBJECT}', got '{outline['course_subject']}'"

    def test_outline_level_matches_target(self, outline_result):
        """Test that outline level matches target course."""
        outline = outline_result["outline"]
        assert outline["course_level"] == EXPECTED_LEVEL, \
            f"Expected level '{EXPECTED_LEVEL}', got '{outline['course_level']}'"

    def test_all_entries_have_required_fields(self, outline_result):
        """Test that all outline entries have required fields."""
        outline = outline_result["outline"]
        required_fields = [
            "order", "lesson_type", "label_hint", "block_name",
            "block_index", "primary_outcome_or_skill",
            "standards_or_skills_codes", "rationale"
        ]

        for i, entry in enumerate(outline["outlines"]):
            for field in required_fields:
                assert field in entry, f"Entry {i+1} missing required field '{field}'"

    def test_all_entries_have_non_empty_skills(self, outline_result):
        """Test that all entries have at least one skill/standard."""
        outline = outline_result["outline"]

        for i, entry in enumerate(outline["outlines"]):
            skills = entry.get("standards_or_skills_codes", [])
            assert len(skills) >= 1, f"Entry {i+1} has empty standards_or_skills_codes"

    def test_all_entries_have_valid_lesson_types(self, outline_result):
        """Test that all entries have valid lesson types.

        NOTE: Uses simplified outline lesson types (teach + mock_exam only).
        Other pedagogical patterns are card types within teach lessons.
        """
        outline = outline_result["outline"]
        # Simplified outline types - only teach and mock_exam
        valid_outline_types = {"teach", "mock_exam"}

        for i, entry in enumerate(outline["outlines"]):
            lesson_type = entry.get("lesson_type")
            assert lesson_type in valid_outline_types, \
                f"Entry {i+1} has invalid outline lesson_type '{lesson_type}'. " \
                f"Only {valid_outline_types} are valid for outlines."

    def test_outline_json_file_valid(self, outline_result):
        """Test that lesson_outline.json file is valid JSON."""
        outline_path = Path(outline_result["outline_path"])
        content = outline_path.read_text()

        # Should parse without error
        data = json.loads(content)

        # Should have required top-level fields
        assert "course_subject" in data
        assert "course_level" in data
        assert "total_lessons" in data
        assert "structure_type" in data
        assert "outlines" in data

    def test_pydantic_validation_passes(self, outline_result):
        """Test that outline passes full Pydantic validation."""
        from src.tools.sow_schema_models import LessonOutline

        outline_path = Path(outline_result["outline_path"])
        outline_json = outline_path.read_text()

        # This should not raise any exception
        validated = LessonOutline.model_validate_json(outline_json)

        assert validated.total_lessons == outline_result["total_lessons"]
        assert validated.structure_type == EXPECTED_STRUCTURE_TYPE


# ═══════════════════════════════════════════════════════════════════════════════
# Diagnostic/Debug Tests (Optional - Can be skipped)
# ═══════════════════════════════════════════════════════════════════════════════

class TestPhase1OutlineDiagnostics:
    """Diagnostic tests for debugging - print outline details."""

    def test_print_outline_summary(self, outline_result, capsys):
        """Print outline summary for manual inspection."""
        outline = outline_result["outline"]

        print("\n" + "=" * 60)
        print("PHASE 1 OUTLINE GENERATION - SUMMARY")
        print("=" * 60)
        print(f"Course: {outline['course_subject']} ({outline['course_level']})")
        print(f"Structure Type: {outline['structure_type']}")
        print(f"Total Lessons: {outline['total_lessons']}")
        print(f"Workspace: {outline_result['workspace_path']}")
        print("\nLesson Type Distribution:")

        type_counts = {}
        for entry in outline["outlines"]:
            lt = entry["lesson_type"]
            type_counts[lt] = type_counts.get(lt, 0) + 1

        for lt, count in sorted(type_counts.items()):
            print(f"  - {lt}: {count}")

        print("\nBlocks:")
        blocks = set(e["block_name"] for e in outline["outlines"])
        for block in sorted(blocks):
            print(f"  - {block}")

        print("=" * 60)

        # Test always passes - this is for output inspection
        assert True

    def test_print_outline_entries(self, outline_result, capsys):
        """Print all outline entries for manual inspection."""
        outline = outline_result["outline"]

        print("\n" + "-" * 60)
        print("OUTLINE ENTRIES")
        print("-" * 60)

        for entry in outline["outlines"]:
            print(f"\n[{entry['order']:2d}] {entry['lesson_type']:20s} | {entry['label_hint']}")
            print(f"     Block: {entry['block_name']} ({entry['block_index']})")
            print(f"     Skills: {entry['standards_or_skills_codes']}")

        print("-" * 60)

        # Test always passes - this is for output inspection
        assert True
