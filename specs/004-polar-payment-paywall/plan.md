# Implementation Plan: Polar Payment Gateway with AI Lesson Paywall

**Branch**: `004-polar-payment-paywall` | **Date**: 2025-11-13 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/004-polar-payment-paywall/spec.md`

## Summary

Integrate Polar payment processing to gate AI-powered lesson features behind a $5.99/month "Student Plus" subscription. Free users can browse the dashboard and see lesson recommendations but encounter a paywall modal when attempting to start lessons. Paid users gain immediate access to all LLM-consuming features (lesson execution, AI recommendations, spaced repetition, AI tutor). Test users bypass paywall via email domain allowlist. System uses Polar's hosted checkout, webhook-based subscription synchronization, and cached status checks for performance.

## Technical Context

**Language/Version**: TypeScript 5.x (Next.js 14 App Router), Python 3.11+ (Appwrite Functions if needed)
**Primary Dependencies**:
- `@polar-sh/nextjs` - Polar SDK for Next.js
- `zod` - Runtime validation
- `appwrite` (existing) - User authentication, database
- `@assistant-ui/react` (existing) - Frontend UI

**Storage**: Appwrite database (existing) - new collections: `subscriptions`, `webhook_events`
**Testing**: Playwright (existing), Manual with test cards in Polar sandbox
**Target Platform**: Vercel/Node.js (Next.js app), web browsers
**Project Type**: Web application (Next.js frontend + API routes)
**Performance Goals**:
- Paywall check: <500ms (95th percentile)
- Webhook processing: <5 seconds
- Checkout redirect: <2 seconds

**Constraints**:
- Polar USD-only (no multi-currency at product level)
- Webhook endpoint must be publicly accessible (HTTPS)
- Session-based caching (1-hour TTL)

**Scale/Scope**:
- ~100 concurrent users expected
- Single subscription tier (Student Plus)
- Estimated 50-100 webhook events/day

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Verify compliance with `.specify/memory/constitution.md`:

- [x] **Fast-Fail**: All subscription checks throw exceptions on failure (FR-003, FR-031, FR-034). No silent fallbacks to free tier.
- [x] **Code Quality**: Design uses service modules (<500 lines): `SubscriptionService`, `PaywallGuard`, `PolarWebhookHandler`. Functions kept under 50 lines with extracted helpers.
- [x] **Documentation**: Implementation updates CLAUDE.md with Polar setup, environment variables, webhook testing.
- [x] **Testing**: Playwright tests for: free user paywall, paid user access, checkout flow, webhook simulation.
- [x] **Architecture**: Frontend-only changes (no LangGraph/Aegra backend modifications). Compatible with existing dual-backend strategy.

**Violations Requiring Justification**: None

## Project Structure

### Documentation (this feature)

```
specs/004-polar-payment-paywall/
├── plan.md              # This file
├── research.md          # Polar SDK patterns, webhook handling
├── data-model.md        # Subscription, WebhookEvent schemas
├── quickstart.md        # Developer setup guide
├── contracts/           # API route contracts
│   ├── checkout.yaml    # POST /api/polar/checkout
│   ├── webhook.yaml     # POST /api/polar/webhook
│   └── subscription.yaml # GET /api/subscription/status
└── tasks.md             # Generated by /speckit.tasks
```

### Source Code (repository root)

```
assistant-ui-frontend/
├── app/
│   └── api/
│       └── polar/
│           ├── checkout/route.ts       # Polar checkout handler (NEW)
│           ├── portal/route.ts         # Customer portal redirect (NEW)
│           └── webhook/route.ts        # Webhook endpoint (NEW)
├── lib/
│   ├── services/
│   │   ├── subscription-service.ts     # Subscription CRUD (NEW)
│   │   └── polar-client.ts             # Polar SDK wrapper (NEW)
│   ├── middleware/
│   │   └── paywall-guard.ts            # Subscription check middleware (NEW)
│   └── types/
│       └── subscription.ts             # TypeScript interfaces (NEW)
├── components/
│   ├── paywall/
│   │   ├── PaywallModal.tsx            # Upgrade prompt (NEW)
│   │   └── SubscriptionBadge.tsx       # "Student Plus" indicator (NEW)
│   ├── dashboard/
│   │   └── EnhancedStudentDashboard.tsx # Add paywall check (MODIFIED)
│   └── SessionChatAssistant.tsx        # Add paywall check (MODIFIED)
└── .env.local.example                   # Add Polar vars (MODIFIED)
```

**Structure Decision**: Extends existing Next.js frontend with new API routes for Polar integration. Subscription logic lives in `lib/services/` following existing service pattern. Paywall components in dedicated `/paywall` directory. No backend changes needed - Appwrite handles data storage.

## Complexity Tracking

*No constitution violations - section not required*

## Phase 0: Research & Technical Decisions

See [research.md](./research.md) for detailed findings on:

1. **Polar SDK Initialization**: Environment variables, sandbox vs production mode
2. **Webhook Security**: Signature validation, idempotency, event types
3. **Subscription State Machine**: Status transitions (active → cancelled → expired)
4. **Customer ID Mapping**: Internal user ID → Polar customer ID resolution
5. **Error Handling Patterns**: Polar API errors, rate limiting (429), network failures
6. **Testing Strategy**: Sandbox mode, test card numbers, webhook event simulation

**Key Decisions**:
- Use Polar's Next.js SDK adapters (not raw API) for type safety
- Store Polar customer ID in Appwrite `subscriptions` collection
- Cache subscription status in server session (1-hour TTL)
- Alert admins after 3 consecutive webhook failures
- Test users bypass via environment-configured email domain list

## Phase 1: Design & Contracts

### Data Model

See [data-model.md](./data-model.md) for complete schemas.

**New Appwrite Collections**:
1. `subscriptions` - User subscription records (Polar sync)
2. `webhook_events` - Audit log for webhook processing

**Modified Collections**:
- `students` - Add `testUser: boolean` flag (computed from email domain)

### API Contracts

See `/contracts/*.yaml` for OpenAPI specifications.

**New Endpoints**:
1. `GET /api/polar/checkout` - Create checkout session, redirect to Polar
2. `GET /api/polar/portal` - Redirect to customer portal
3. `POST /api/polar/webhook` - Handle Polar webhook events
4. `GET /api/subscription/status` - Check current user's subscription

### Component Architecture

**Paywall Flow**:
```
User clicks "Start Lesson"
  → PaywallGuard.checkAccess(userId)
    → SubscriptionService.getStatus(userId)
      → IF test user → ALLOW
      → IF paid (active) → ALLOW
      → ELSE → PaywallModal.show()
```

**Webhook Flow**:
```
Polar sends webhook
  → route.ts validates signature
  → PolarWebhookHandler.process(event)
    → SubscriptionService.syncFromPolar(event.data)
      → Appwrite transaction: upsert subscription
      → Log to webhook_events
    → Return 200 OK
```

### Testing Strategy

**Manual Tests** (Playwright):
1. Free user sees paywall on lesson start
2. Paid user starts lesson immediately
3. Test user bypasses paywall
4. Checkout flow completes successfully
5. Subscription status displays correctly

**Webhook Tests**:
- Simulate `checkout.completed` event
- Verify subscription created in database
- Test idempotency (duplicate events)
- Validate signature rejection

## Phase 2: Implementation Sequence

*Tasks generated by `/speckit.tasks` command - see tasks.md*

**High-Level Sequence**:
1. Setup: Install Polar SDK, add environment variables
2. Data Layer: Create Appwrite collections, migration scripts
3. Services: Build SubscriptionService, PolarClient wrapper
4. API Routes: Implement checkout, portal, webhook handlers
5. Middleware: Create PaywallGuard for access checks
6. UI Components: PaywallModal, SubscriptionBadge
7. Integration: Add paywall to Dashboard and SessionChatAssistant
8. Testing: Playwright tests, sandbox testing
9. Documentation: Update CLAUDE.md, README

## Deployment Considerations

**Environment Variables** (add to Vercel):
```bash
POLAR_ACCESS_TOKEN=polar_xxx        # Polar API key
POLAR_WEBHOOK_SECRET=whsec_xxx      # Webhook signing secret
POLAR_PRODUCT_ID=prod_xxx           # Student Plus product ID
TEST_USER_DOMAINS=scottishailessons.com  # Comma-separated
```

**Webhook Configuration** (Polar dashboard):
- URL: `https://yourapp.com/api/polar/webhook`
- Events: `checkout.completed`, `subscription.*`, `benefit.grant.*`

**Database Indexes** (Appwrite):
- `subscriptions.userId` (unique)
- `subscriptions.polarSubscriptionId` (unique)
- `webhook_events.eventId` (unique)

**Monitoring**:
- Track webhook processing duration (log to stdout)
- Alert on 3 consecutive webhook failures (TODO: implement alerting)
- Monitor subscription check latency (<500ms target)

## Risks & Mitigations

| Risk | Mitigation Strategy |
|------|---------------------|
| Polar API downtime during checkout | Cache existing subscription status (1hr TTL), show graceful error for new signups |
| Webhook delivery delays | Implement 5-minute client-side polling after checkout redirect |
| Race condition (webhook arrives before redirect) | Use idempotency keys, optimistic locking on subscription updates |
| Test user email leaks to production | Store domains in environment variables, audit access logs regularly |
| Stale subscription cache blocks paid users | TTL of 1 hour, force refresh on 401 errors, manual refresh button in UI |

## Success Criteria Reference

*From spec.md - validation during QA:*

- SC-001: Paywall appears <2 seconds after lesson click
- SC-003: >70% checkout completion rate (monitor Polar analytics)
- SC-006: Zero false positives/negatives in subscription checks
- SC-007: 95% of status checks <500ms (monitor logs)
- SC-009: Idempotent webhook processing (test with duplicate events)

## Next Steps

1. Run `/speckit.tasks` to generate task breakdown
2. Review `quickstart.md` for local development setup
3. Create Polar sandbox account and obtain test credentials
4. Begin Phase 2 implementation following task order
